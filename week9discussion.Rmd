---
title: "Stats 20: Week 9 Discussion Assignment"
author: "Brandon Liu"
date: "2025/03/04"
output:
  pdf_document:
    toc: true
    toc_depth: '4'
  html_document:
    toc: true
    toc_depth: 4
    toc_float: true
    code_folding: show
---
\newpage

## Question 1
With the help of ChatGPT, implement a great-circle distance calculator using the haversine function.

You should implement this in a few steps:
• Create a function called my_hav that calculates the haversine of an angle theta,
• Create a function that converts a given latitude and longitude from degrees to radians.
• Create a function called my_haversine_distance that calls your previously implemented functions.

This function should calculate the great-circle distance between two given coordinates on Earth. Ensure that your function has a default radius argument of 6731 (the radius of the Earth). In what unit of measurement is the radius argument?

NOTE: Coordinates that are south of the equator and west of the Prime Meridian should be negative values.

```{r Question 1}
# Function to calculate the haversine of an angle (in radians)
my_hav <- function(theta) {
  return((sin(theta / 2))^2)
}

# Function to convert degrees to radians
deg_to_rad <- function(degrees) {
  return(degrees * pi / 180)
}

# Function to calculate the great-circle distance between two coordinates
my_haversine_distance <- function(lat1, lon1, lat2, lon2, radius = 6731) {
  # Convert latitude and longitude from degrees to radians
  lat1 <- deg_to_rad(lat1)
  lon1 <- deg_to_rad(lon1)
  lat2 <- deg_to_rad(lat2)
  lon2 <- deg_to_rad(lon2)
  
  # Compute differences
  dlat <- lat2 - lat1
  dlon <- lon2 - lon1
  
  # Apply the Haversine formula
  a <- my_hav(dlat) + cos(lat1) * cos(lat2) * my_hav(dlon)
  c <- 2 * atan2(sqrt(a), sqrt(1 - a))
  
  # Compute the distance
  distance <- radius * c
  return(distance)
}

# Los Angeles to New York City
my_haversine_distance(34.0522, -118.2437, 40.7128, -74.0060)
```
The unit of measurement for the radius argument is kilometers because the default radius of Earth is set to 6731 kilometers.

\newpage

## Question 2
Implement a function called great_circle_cosine that does not use the arcsine function in your code. What function (or law) is being implemented? Please highlight the differences in this function implementation with the function implemented in problem 1.

```{r Question 2}
# Function to convert degrees to radians
deg_to_rad <- function(degrees) {
  return(degrees * pi / 180)
}

# Function to calculate great-circle distance using the spherical law of cosines
great_circle_cosine <- function(lat1, lon1, lat2, lon2, radius = 6731) {
  # Convert latitude and longitude from degrees to radians
  lat1 <- deg_to_rad(lat1)
  lon1 <- deg_to_rad(lon1)
  lat2 <- deg_to_rad(lat2)
  lon2 <- deg_to_rad(lon2)

  # Apply the spherical law of cosines formula
  delta_sigma <- acos(sin(lat1) * sin(lat2) + cos(lat1) * cos(lat2) * 
                        cos(lon2 - lon1))
  
  # Compute the distance
  distance <- radius * delta_sigma
  return(distance)
}

# Log Angeles to New York City
great_circle_cosine(34.0522, -118.2437, 40.7128, -74.0060)
```
The function or law that is being implemented is the Spherical Law of Cosines.

There are several key differences between this law's implementation and the Haversine Formula. Specifically, the Spherical Law of Cosines uses sin, cos, and acos (cos-inverse), while Haversine uses sin and atan2 (tan-inverse). Additionally, the Spherical Law of Cosines is prone to minor errors generated by acos. Since acos is only defined for [-1, 1] and small rounding errors may cause the value of acos to be slightly less than -1 or slightly greater than 1, this may cause the function to fail. Haversine avoids this problem by using sin and atan2.

\newpage

## Question 3
Using your implemented functions, create vectors that contain the great-circle distance between UCLA
and each of the listed universities in coordinates. One vector should contain the results from your my_haversine_distance function; another vector should have the results from great_circle_cosine function. Are there major differences in the calculated values?

```{r Question 3}
ref_point <- c(34.0689, -118.4452) # coordinates for UCLA
# UCSD, UofU, Columbia, UNI (Lima, Peru), ETH Zurich
coordinates <- list(
  UCSD = c(32.8801, -117.2340),
  UofUtah = c(40.7658, -111.8483),
  Columbia = c(40.8075, -73.9626),
  UNI = c(-12.0219, -77.0486),
  ETH_Zurich = c(47.3763, 8.5482)
)

# UCLA coordinates
ref_point <- c(34.0689, -118.4452)

# Coordinates of other universities
coordinates <- list(
  UCSD = c(32.8801, -117.2340),
  UofUtah = c(40.7658, -111.8483),
  Columbia = c(40.8075, -73.9626),
  UNI = c(-12.0219, -77.0486),
  ETH_Zurich = c(47.3763, 8.5482)
)

# Haversine formula for calculating great-circle distance
my_haversine_distance <- function(lat1, lon1, lat2, lon2) {
  R <- 6371 # Earth's radius in kilometers
  phi1 <- lat1 * pi / 180
  phi2 <- lat2 * pi / 180
  delta_phi <- (lat2 - lat1) * pi / 180
  delta_lambda <- (lon2 - lon1) * pi / 180
  
  a <- sin(delta_phi / 2)^2 + cos(phi1) * cos(phi2) * sin(delta_lambda / 2)^2
  c <- 2 * atan2(sqrt(a), sqrt(1 - a))
  
  distance <- R * c # in kilometers
  return(distance)
}

# Great-circle distance using the spherical law of cosines
great_circle_cosine <- function(lat1, lon1, lat2, lon2) {
  R <- 6371 # Earth's radius in kilometers
  phi1 <- lat1 * pi / 180
  phi2 <- lat2 * pi / 180
  delta_lambda <- (lon2 - lon1) * pi / 180
  
  distance <- R * acos(sin(phi1) * sin(phi2) + cos(phi1) * cos(phi2) * 
                         cos(delta_lambda))
  return(distance)
}

# Initialize empty vectors to store the distances
haversine_distances <- c()
cosine_distances <- c()

# Calculate the distances using a loop
for (university in names(coordinates)) {
  coord <- coordinates[[university]]
  
  # Haversine distance
  haversine_distances[university] <- 
    my_haversine_distance(ref_point[1], ref_point[2], coord[1], coord[2])
  
  # Cosine distance
  cosine_distances[university] <- 
    great_circle_cosine(ref_point[1], ref_point[2], coord[1], coord[2])
}

# Output the results
haversine_distances
cosine_distances

# Calculate the absolute differences between the two methods
difference <- haversine_distances - cosine_distances

# Output the differences
difference
```
The haversine_distances vector implemented the results from the my_haversine_distance function and the cosine_distances vector implemented the results from the great_circle_cosine function.

As seen by the last line of output, there are no major differences between the calculated values. One explanation for this is since the distances between UCLA and the other universities are relatively large, the approximation error will be small.

\newpage

## Question 4
What are some edge cases where the haversine calculations and the spherical cosine calculations might differ? Try asking ChatGPT for help in coming up with these edge cases, and try to calculate the differences between the two functions under these edge cases.

```{r Question 4}
# Edge Case 1: Very small distance (near UCLA)
ref_point <- c(34.0689, -118.4452) # UCLA
close_point <- c(34.0689 + 0.0001, -118.4452 + 0.0001) # 10 meters from UCLA

# Edge Case 2: Points near the poles (North Pole and UCLA)
north_pole <- c(90, 0) # North Pole
south_pole <- c(-90, 0) # South Pole

# Edge Case 3: Points near the anti-meridian (near 180° longitude)
point_anti_meridian <- c(0, 179.9999) # Close to the international date line

# Edge Case 4: Antipodal points (opposite sides of the globe)
antipodal_point <- c(-34.0689, 61.5548) # Roughly opposite to UCLA

# Calculate distances using both methods
dist_haversine_close <- my_haversine_distance(ref_point[1], ref_point[2], 
                                              close_point[1], close_point[2])
dist_cosine_close <- great_circle_cosine(ref_point[1], ref_point[2], 
                                         close_point[1], close_point[2])

dist_haversine_north_pole <- my_haversine_distance(ref_point[1], ref_point[2], 
                                                   north_pole[1], north_pole[2])
dist_cosine_north_pole <- great_circle_cosine(ref_point[1], ref_point[2], 
                                              north_pole[1], north_pole[2])

dist_haversine_anti_meridian <- 
  my_haversine_distance(ref_point[1], ref_point[2], point_anti_meridian[1], 
                        point_anti_meridian[2])
dist_cosine_anti_meridian <- 
  great_circle_cosine(ref_point[1], ref_point[2], point_anti_meridian[1], 
                      point_anti_meridian[2])

dist_haversine_antipodal <- 
  my_haversine_distance(ref_point[1], ref_point[2], antipodal_point[1], 
                        antipodal_point[2])
dist_cosine_antipodal <- 
  great_circle_cosine(ref_point[1], ref_point[2], antipodal_point[1], 
                      antipodal_point[2])

# Output the results for comparison
dist_haversine_close
dist_cosine_close
dist_haversine_north_pole
dist_cosine_north_pole
dist_haversine_anti_meridian
dist_cosine_anti_meridian
dist_haversine_antipodal
dist_cosine_antipodal

# Calculate the differences for each case
diff_close <- dist_haversine_close - dist_cosine_close
diff_north_pole <- dist_haversine_north_pole - dist_cosine_north_pole
diff_anti_meridian <- dist_haversine_anti_meridian - dist_cosine_anti_meridian
diff_antipodal <- dist_haversine_antipodal - dist_cosine_antipodal

# Output the differences
diff_close
diff_north_pole
diff_anti_meridian
diff_antipodal
```

Edge Case 1: Very small distances (close proximity):
When two points are very close (like 10 meters apart), both formulas should give nearly identical results. However, the Spherical Law of Cosines may output small errors due to how it handles infinitesimally (very small) distances.

Edge Case 2: Points near the poles (North/South Pole):
The formulas might differ here (latitude 90° and -90°)  because the spherical law of cosines can have inaccuracies at extreme latitudes, while the Haversine formula handles such values better.

Edge Case 3: Points near the anti-meridian (longitude ±180°):
The anti-meridian (near 180° longitude) is the opposite side of the globe. The Haversine formula is more accurate here, while the Spherical Law of Cosines tends to make errors when dealing with extreme longitudes.

Edge Case 4: Antipodal points (opposite sides of the Earth):
When two points are on opposite sides of the Earth (antipodes), both formulas should give very similar results, but small differences may arise due to disparities in approximations used by each formula.

\newpage

## Question 5
Finally, plot the distances on a world map using ggplot2. Make a plot in latitude vs. longitude (a.k.a mercator or geographical projection) as well as an orthographic projection. No further instructions or clarification will be provided for this question. You will rely on ChatGPT for this problem. Also, for problem 5, all functions from any R package will be allowed here.

```{r Question 5(i)}
# Install and load necessary libraries
# install.packages("ggplot2")
# install.packages("sf")
# install.packages("maps")
library(ggplot2)
library(sf)
library(maps)

# Coordinates of UCLA and other universities
ref_point <- c(34.0689, -118.4452)  # UCLA
coordinates <- list(
  UCSD = c(32.8801, -117.2340),
  UofUtah = c(40.7658, -111.8483),
  Columbia = c(40.8075, -73.9626),
  UNI = c(-12.0219, -77.0486),
  ETH_Zurich = c(47.3763, 8.5482)
)

# Create empty vectors for latitudes, longitudes, and distances
latitudes <- c(ref_point[1])
longitudes <- c(ref_point[2])
distances_haversine <- c(0)
distances_cosine <- c(0)
university_names <- c("UCLA")

# Loop to calculate coordinates and distances for each university
for (university in names(coordinates)) {
  latitudes <- c(latitudes, coordinates[[university]][1])
  longitudes <- c(longitudes, coordinates[[university]][2])
  
  haversine_distance <- 
    my_haversine_distance(ref_point[1],
                          ref_point[2], 
                          coordinates[[university]][1], 
                          coordinates[[university]][2])
  cosine_distance <- 
    great_circle_cosine(ref_point[1],
                        ref_point[2], 
                        coordinates[[university]][1], 
                        coordinates[[university]][2])
  
  distances_haversine <- c(distances_haversine, haversine_distance)
  distances_cosine <- c(distances_cosine, cosine_distance)
  university_names <- c(university_names, university)
}

# Prepare the data frame for plotting
df <- data.frame(
  University = university_names,
  Latitude = latitudes,
  Longitude = longitudes,
  Distance_Haversine = distances_haversine,
  Distance_Cosine = distances_cosine
)

# Plot on Mercator projection
ggplot(df) +
  borders("world") +
  geom_point(aes(x = Longitude, y = Latitude, color = University), size = 3) +
  labs(title = "University Locations (Mercator Projection)",
       x = "Longitude", y = "Latitude") +
  theme_minimal()
```

```{r Question 5(ii)}
# Plot on Orthographic projection
ggplot(df) +
  borders("world") +
  geom_point(aes(x = Longitude, y = Latitude, color = University), size = 3) +
  # Orthographic projection
  coord_sf(crs = "+proj=ortho +lat_0=34.0689 +lon_0=-118.4452") +
  labs(title = "University Locations (Orthographic Projection)",
       x = "Longitude", y = "Latitude") +
  theme_minimal()
```
